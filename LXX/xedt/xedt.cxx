// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "xedt.h"
#include <FL/fl_ask.H>
#include <FL/Fl_File_Chooser.H>
#include <FL/Fl_Tree_Item.H>
#include "xmltag.h"
static XMLTag g_XML; 

Fl_Text_Editor *tag_data=(Fl_Text_Editor *)0;

Fl_Double_Window* edit_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(485, 410);
    w = o;
    { Fl_Tabs* o = new Fl_Tabs(5, 5, 475, 400);
      { Fl_Group* o = new Fl_Group(5, 35, 475, 370, "Tag");
        { tag_data = new Fl_Text_Editor(10, 40, 465, 360);
          tag_data->labelfont(4);
        } // Fl_Text_Editor* tag_data
        o->end();
      } // Fl_Group* o
      o->end();
      Fl_Group::current()->resizable(o);
    } // Fl_Tabs* o
    o->end();
  } // Fl_Double_Window* o
  return w;
}

XTree::XTree(int x, int y, int w, int h ) : Fl_Tree( x, y, w, h ) {
  // Constuctor
}

/**
   Added for right click detection
*/
int XTree::handle(int e) {
  //printf("Hello, World!\n");
  
  int ret = Fl_Tree::handle(e);
  
  switch( e )
  {
  
  	case FL_PUSH:
  		if( Fl::event_button() == FL_RIGHT_MOUSE )
  		{
  			//printf("Right Down");
  			//fflush( stdout );
  		}
  		break;
  		//return 1;
  	case FL_RELEASE:
  		if( Fl::event_button() == FL_RIGHT_MOUSE)
  		{
  			//printf("Right Up");
  			//fflush( stdout );
  			Fl_Tree_Item* ti = this->first_selected_item();
  			
  			if( ti != NULL )
  			{
  				printf( "%s\n", ((XMLTag*)ti->user_data())->getXMLFormatted() );
  				edit_window()->show();
  				tag_data->buffer( new Fl_Text_Buffer() );
  				tag_data->buffer()->text(((XMLTag*)ti->user_data())->getXMLFormatted()); 
  			}
  		}
  		break;
  		//return 1;
  	default:
  		break;
  }
  
  return ret;
}

static void fill_recursive( Fl_Tree_Prefs& tpf, Fl_Tree_Item* tp, XMLTag &xr ) {
  //for( int i=0; i < xr.count(); i++ )
  {		
  	std::string strAttrs("");
  
  	for( int a=0; a < xr.attribute_count(); a++ )
  	{
  		strAttrs += " ";
  		strAttrs += xr.attribute_name( a ) + "=";
  		strAttrs += "\"" + xr.attribute( a ) + "\"";		
  	}
  	
  	Fl_Tree_Item* p = tp->add( tpf, ("<"+xr.name() + strAttrs+">").c_str()  );
  	
  	p->user_data( (void*) &xr );
  		
  	for( int r=0; r < xr.count(); r++ )
  		fill_recursive( tpf, p, xr[r] );
  }
}

static void fill_tree( Fl_Tree_Prefs& tpf, Fl_Tree_Item* tp, XMLTag &xr ) {
  for( int i=0; i < xr.count(); i++ )
  {		
  	std::string strAttrs("");
  
  	for( int a=0; a < xr[i].attribute_count(); a++ )
  	{
  		strAttrs += " ";
  		strAttrs += xr[i].attribute_name( a ) + "=";
  		strAttrs += "\"" + xr[i].attribute( a ) + "\"";		
  	}
  	
  	Fl_Tree_Item* p = tp->add( tpf, (xr[i].name() + strAttrs).c_str()  );
  	
  	p->user_data( (void*) &xr[i] );
  		
  	fill_tree( tpf, p, xr[i] );
  }
}

static XTree *tree=(XTree *)0;

static void cb_tree(XTree* o, void* v) {
  //printf( "0x%016x\n\n", o->callback_item() );
//printf( "%s\n\n", ( (XMLTag*)(((Fl_Tree_Item*)(o->callback_item()) )->user_data()) )->getXMLFormatted() );
//fflush( stdout );

switch( tree->callback_reason() )
{
	case FL_TREE_REASON_SELECTED:
	{
		printf( "%d\n", Fl::event_button() );
		fflush( stdout );	
	
		if ( Fl::event_button() == FL_RIGHT_MOUSE ) 
		{
			printf( "%s\n\n", ( (XMLTag*)(((Fl_Tree_Item*)(o->callback_item()) )->user_data()) )->getXMLFormatted() );
			fflush( stdout );
		}
		break;
	}
	case FL_TREE_REASON_OPENED:
	case FL_TREE_REASON_CLOSED:
	//case FL_TREE_REASON_RESELECTED:
	case FL_TREE_REASON_DESELECTED:
	default:
	break;
}



//printf( "%s\n", ( (XMLTag*)(((Fl_Tree_Item*)v)->user_data()) )->getXMLFormatted() );
}

Fl_Button *open=(Fl_Button *)0;

static void cb_open(Fl_Button*, void*) {
  Fl_Tree_Prefs prefs;

const char * fname = fl_file_chooser( "Choose an XML file to read", "*.xml", NULL, 0 );

if( fname != NULL )
{

	try
	{
		g_XML.load( fname );

		//printf( "%s\n", g_XML.getXML() );
		
		fflush( stdout );	
		
		Fl_Tree_Item* ti = NULL;	
	
		fill_recursive( prefs, 	
			tree->root(),
			g_XML );
	}
	catch( XMLTagException &e )
	{
		fl_alert( "%s\n%s\n 0x%02.02x(%c) position: %d", e.msg.c_str(), e.sample.c_str(), e.byte, e.byte, e.pos );
	}
	catch(...)
	{
		fl_alert( "Could not open %s", fname );
	}	

}

tree->redraw();
}

Fl_Double_Window* make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(895, 605);
    w = o;
    { Fl_Group* o = new Fl_Group(10, 10, 875, 510);
      { tree = new XTree(10, 10, 875, 510);
        tree->box(FL_DOWN_BOX);
        tree->color(FL_BACKGROUND2_COLOR);
        tree->selection_color(FL_SELECTION_COLOR);
        tree->labeltype(FL_NORMAL_LABEL);
        tree->labelfont(0);
        tree->labelsize(14);
        tree->labelcolor(FL_FOREGROUND_COLOR);
        tree->callback((Fl_Callback*)cb_tree);
        tree->align(Fl_Align(FL_ALIGN_TOP));
        tree->when(FL_WHEN_CHANGED);
      } // XTree* tree
      o->end();
      Fl_Group::current()->resizable(o);
    } // Fl_Group* o
    { open = new Fl_Button(10, 570, 105, 25, "OpenXML");
      open->callback((Fl_Callback*)cb_open);
    } // Fl_Button* open
    o->end();
  } // Fl_Double_Window* o
  return w;
}

int main(int argc, char **argv) {
  make_window()->show();
  
  tree->showroot(0);
  
  return Fl::run();
  return Fl::run();
}
